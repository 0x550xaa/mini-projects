# !/usr/bin/env python3

from sys import stdout
import timeit
import itertools
from string import ascii_letters, digits, punctuation
from random import choice, randint


class TimingAttackDemo:
    """Timing attack proof-of-concept."""
    def __init__(self, pw: str, max_len: int, verbose=True):
        # NOTE: in a realistic setup, we would not be able to know the correct password before hand.
        self.true_pw: str = pw
        self.max_len: int = max_len
        self.allowed_chars: str = ascii_letters + digits + punctuation + ' _'  # hardcoded for simplicity's sake.
        self.verbose: bool = verbose
        if verbose:
            print(f'[#-TimingAttackDemo]\n    * target password:   {pw}')

    """Try to guess the password length."""
    def crack_length(self, trials=1000, iterations=3) -> int:
        rtimes = list()
        for _ in range(iterations):
            temp_rtimes = list()
            for j in range(self.max_len):
                t = timeit.repeat(
                    stmt=f'self._check_pw(x)',
                    setup=f'x={self._rnd_str(j)!r}',
                    number=trials,
                    globals={'self': self},
                    repeat=10
                )
                temp_rtimes.append(min(t))  # min(t) minimizes lag's influence on the prediction.

            # append the index of the largest number in temp_rtimes to rtimes.
            rtimes.append(temp_rtimes.index(max(temp_rtimes)))

        # p_len is the number that repeats the most in rtimes.
        p_len: int = sorted(rtimes, key=lambda i: rtimes.count(i))[-1]

        if self.verbose:
            print(f'    * predicted length:  {p_len}\n')

        return p_len

    """Crack the password knowing its length."""
    def crack_pw(self, p_len: int, trials=1000) -> str:
        guess: str = self._rnd_str(p_len)  # NOTE:  one random allowed character * p_len would equally work.
        counter = itertools.count()

        while True:
            i: int = next(counter) % p_len
            for c in self.allowed_chars:
                alt: str = guess[:i] + c + guess[i + 1:]  # replace guess[i] with c.
                alt_time = timeit.repeat(
                    stmt=f'self._check_pw(x)',
                    setup=f'x={alt!r}',
                    number=trials,
                    globals={'self': self},
                )

                guess_time = timeit.repeat(
                    stmt=f'self._check_pw(x)',
                    setup=f'x={guess!r}',
                    number=trials,
                    globals={'self': self},
                )

                if self._check_pw(alt):
                    if self.verbose:
                        stdout.write(f'\r > \'{alt}\' (100%) ')
                    return alt  # if _check_pw returns True, return the alt string.
                #  else:
                if min(alt_time) > min(guess_time):
                    # NOTE: lag can severely interfere with this comparison, making it difficult if not impossible to
                    # obtain the real password. Be sure to run this demo on a sufficently stable PC.

                    # if _check_pw(alt) took longer to execute, alt is closer to the real password then guess is.
                    # Therefore, assign the alt string to the guess variable.
                    guess = alt
                    if self.verbose:
                        stdout.write(f'\r > \'{guess}\' ({round(self._pw_per(guess), 1)}%) ')

    """Password check function."""
    def _check_pw(self, pw: str) -> bool:
        # NOTE: this function simulates a comparison between two strings. You could theoretically just use
        # 'return pw == self.true_pw', however, unless you have an incredibly stable PC, this will not work.

        # part 1: length check.
        if len(pw) != len(self.true_pw):
            return False

        # part 2: compare the two strings character by character.
        for i in range(len(self.true_pw)):
            if pw[i] != self.true_pw[i]:
                return False
        return True

    """Calculate completion percentage."""
    def _pw_per(self, pw: str) -> float:
        # NOTE: this function is unnecessary and it is only used to better visualize what is going on.
        x: int = 0
        for i in range(len(self.true_pw)):
            if pw[i] == self.true_pw[i]:
                x += 1
        return x * 100 / len(self.true_pw)  # correctly guessed characters * 100 / password length

    """Ruturn a string of random characters."""
    def _rnd_str(self, length: int) -> str:
        return ''.join(choice(self.allowed_chars) for _ in range(length))


def main():
    pwd: str = 'qwerty1234'
    pwd_length: int = len(pwd) + randint(1, 4)  # NOTE: here randint is used to better simulate a realistic situation.
    tad = TimingAttackDemo(pwd, pwd_length)
    pl: int = tad.crack_length()
    tad.crack_pw(pl)
    input()


if __name__ == '__main__':
    main()
